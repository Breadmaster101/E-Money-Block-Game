<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Money Block Game Alpha v2.3</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: Arial, sans-serif; color: #333; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; max-width: 280px; border: 1px solid #bbb; box-shadow: 0 4px 8px rgba(0,0,0,0.2); z-index: 20; }
        #blocker { position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.75); display: flex; justify-content: center; align-items: center; color: white; z-index: 10; }
        #instructions { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 4px; font-size: 0.9em; color: white; z-index: 5; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background-color: white; transform: translate(-50%, -50%); border-radius: 0px; mix-blend-mode: difference; border: 1px solid black; z-index: 5;}
        #connectionInfo { margin-top: 10px; }
        button { width: 100%; margin-top: 8px; padding: 10px 15px; cursor: pointer; background: #5cb85c; color: white; border: none; border-radius: 5px; font-size: 0.95em; transition: background-color 0.2s ease; box-sizing: border-box; }
        button:hover { background: #4cae4c; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button.backBtn { background: #f0ad4e; }
        button.backBtn:hover { background: #ec971f; }
        #hostIdDisplay { margin-top: 5px; background: #e9e9e9; padding: 8px; border: 1px dashed #ccc; word-wrap: break-word; font-size: 1.2em; min-height:20px; text-align: center; letter-spacing: 2px; font-family: monospace; }
        label { display: block; margin-top: 10px; font-weight: bold; font-size: 0.9em; }
        #blockerInstructions { width: 80%; max-width: 450px; background: #333; padding: 25px; border-radius: 10px; text-align: center; border: 1px solid #555; }
        h2, h3 { margin-top: 0; color: #eee; }
        hr { border: 0; height: 1px; background: #555; margin: 15px 0; }
        strong { color: #444; }
        #initialChoice button { margin-bottom: 5px; }
    </style>
</head>
<body>
     <div id="blocker"> <div id="blockerInstructions"> <h2>E-Money Block Game Alpha v2.3</h2> <p>Click anywhere to start playing!</p> <p>(Requires Pointer Lock)</p <hr> <h3>Controls:</h3> <p>W/A/S/D: Move | Space: Jump (Hold for continuous)</p> <p>Mouse: Look | Left Click: Destroy Block | Right Click: Place Block</p> <p>ESC: Release Mouse</p> <hr> <p>Use the UI (Top Left) to connect...</p> </div> </div>
     <div id="ui"> 
        <div><strong>Status:</strong> <span id="status">Initializing...</span></div> 
        <div id="players">Players: 1</div> 
        <label for="playerNameInput" style="font-weight: bold; font-size: 0.9em; margin-top: 10px; display: block;">Your Name:</label>
        <input type="text" id="playerNameInput" maxlength="16" style="width: 100%; min-height: 30px; margin-top: 5px; box-sizing: border-box; background: #f8f8f8; color: #333; border: 1px solid #ccc; font-size: 1.1em; padding: 5px; text-align: center;">
        <div id="connectionInfo"> 
            <hr>
            <div id="initialChoice">
                <button id="showHostBtn">Host New Game</button>
                <button id="showJoinBtn">Join Game</button>
            </div>
            <div id="hostView" style="display: none;">
                <label>Your Game ID:</label>
                <div id="hostIdDisplay">Generating...</div>
                <button class="backBtn">Cancel</button>
            </div>
            <div id="joinView" style="display: none;">
                <label for="joinIdInput">Enter Game Code:</label>
                <input type="text" id="joinIdInput" placeholder="ABCXYZ" maxlength="6" style="width: 100%; min-height: 30px; margin-top: 5px; box-sizing: border-box; background: #f8f8f8; color: #333; border: 1px solid #ccc; font-size: 1.1em; padding: 5px; text-align: center; text-transform: uppercase; letter-spacing: 2px;">
                <button id="joinBtn">Join Game</button>
                <button class="backBtn">Back</button>
            </div>
        </div> 
    </div>
     <div id="instructions"> W/A/S/D: Move | Space: Jump (Hold) | Mouse: Look | LClick: Destroy | RClick: Place | ESC: Unlock Mouse </div>
     <div id="crosshair"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>

    <script>
        const PLAYER_HEIGHT = 1.5; const PLAYER_WIDTH = 0.6; const PLAYER_SPEED = 5.0; const MOUSE_SENSITIVITY = 0.002;
        const BLOCK_SIZE = 1; const WORLD_SIZE_X = 20; const WORLD_SIZE_Z = 20; const WORLD_HEIGHT = 8; const REACH_DISTANCE = 6;
        const GRAVITY_ACCELERATION = 25.0; const JUMP_VELOCITY = 8.0;

        let scene, camera, renderer; let world = {}; let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isJumpHeld = false; let isOnGround = false;
        let peer; let peers = {}; let connections = {}; let peerId; let isHost = false; let playerStates = {};
        let clock = new THREE.Clock(); let raycaster = new THREE.Raycaster();
        let blockGeometry; let blockMaterials = {}; let textures = {}; let highlightMaterial, highlightMesh;
        let pointerLocked = false;
        let lastUpdateTime = 0;
        let playerName = 'Player' + Math.floor(Math.random() * 1000);

        const blocker = document.getElementById('blocker'); const statusEl = document.getElementById('status');
        const hostIdDisplay = document.getElementById('hostIdDisplay'); const joinIdInput = document.getElementById('joinIdInput');
        const playersEl = document.getElementById('players'); const connectionInfoEl = document.getElementById('connectionInfo');
        const playerNameInput = document.getElementById('playerNameInput');
        
        const initialChoiceView = document.getElementById('initialChoice');
        const hostView = document.getElementById('hostView');
        const joinView = document.getElementById('joinView');
        const showHostBtn = document.getElementById('showHostBtn');
        const showJoinBtn = document.getElementById('showJoinBtn');
        const joinBtn = document.getElementById('joinBtn');
        const backBtns = document.querySelectorAll('.backBtn');


        function init() { setupScene(); setupPlayer(); setupLighting(); setupBlockGeometry(); setupTexturesAndMaterials(); setupWorld(); setupBlockHighlight(); setupControls(); setupEventListeners(); setupPeerJSUI(); playerNameInput.value = playerName; playerNameInput.addEventListener('input', e => { playerName = e.target.value.trim() || 'Player'; if (playerName.length > 16) playerName = playerName.substring(0, 16); e.target.value = playerName; }); statusEl.textContent = 'Ready'; animate(); }
        function setupScene() {  scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 10, 150); camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement); }
        function setupPlayer() {  camera.position.set(0, WORLD_HEIGHT + PLAYER_HEIGHT + 2, 5); camera.rotation.order = 'YXZ'; }
        function setupBlockGeometry() {  blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); }
        function setupTexturesAndMaterials() {  blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); const textureSize = 16; function createCanvasTexture(drawFunction) { const canvas = document.createElement('canvas'); canvas.width = textureSize; canvas.height = textureSize; const context = canvas.getContext('2d'); drawFunction(context, textureSize); const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter; texture.needsUpdate = true; return texture; } function drawDirt(ctx, size) { ctx.fillStyle = '#8B4513'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = 'rgba(0,0,0,0.1)'; for (let i=0; i < size*size*0.3; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); } function drawStone(ctx, size) { ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = 'rgba(0,0,0,0.15)'; for (let i=0; i < size*size*0.4; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); ctx.fillStyle = 'rgba(255,255,255,0.1)'; for (let i=0; i < size*size*0.2; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); } function drawGrassTop(ctx, size) { ctx.fillStyle = '#5a9a5a'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = 'rgba(0,0,0,0.1)'; for (let i=0; i < size*size*0.3; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); ctx.fillStyle = 'rgba(255,255,255,0.05)'; for (let i=0; i < size*size*0.2; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); } function drawGrassSide(ctx, size) { ctx.fillStyle = '#5a9a5a'; ctx.fillRect(0, 0, size, size * 0.25); ctx.fillStyle = '#8B4513'; ctx.fillRect(0, size * 0.25, size, size * 0.75); ctx.fillStyle = 'rgba(0,0,0,0.1)'; for (let i=0; i < size*size*0.75*0.3; ++i) ctx.fillRect(Math.random()*size, size*0.25 + Math.random()*size*0.75, 1, 1); } textures = { grassTop: createCanvasTexture(drawGrassTop), grassSide: createCanvasTexture(drawGrassSide), dirt: createCanvasTexture(drawDirt), stone: createCanvasTexture(drawStone) }; blockMaterials = { grass: [ new THREE.MeshLambertMaterial({ map: textures.grassSide }), new THREE.MeshLambertMaterial({ map: textures.grassSide }), new THREE.MeshLambertMaterial({ map: textures.grassTop }), new THREE.MeshLambertMaterial({ map: textures.dirt }), new THREE.MeshLambertMaterial({ map: textures.grassSide }), new THREE.MeshLambertMaterial({ map: textures.grassSide }) ], dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }), stone: new THREE.MeshLambertMaterial({ map: textures.stone }), }; blockMaterials.fallback = new THREE.MeshLambertMaterial({ color: 0xff00ff }); }
        function setupWorld() {  for (let x = -WORLD_SIZE_X / 2; x < WORLD_SIZE_X / 2; x++) { for (let z = -WORLD_SIZE_Z / 2; z < WORLD_SIZE_Z / 2; z++) { for (let y = 0; y < WORLD_HEIGHT; y++) { let blockType; if (y === WORLD_HEIGHT - 1) blockType = 'grass'; else if (y >= WORLD_HEIGHT - 4 && y < WORLD_HEIGHT -1) blockType = 'dirt'; else blockType = 'stone'; addBlock(x, y, z, blockType, false); } } } }
        function addBlock(x, y, z, type, broadcast = true) {  const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`; if (world[key]) return; let material = blockMaterials[type] || blockMaterials.fallback; const block = new THREE.Mesh(blockGeometry, material); block.position.set(x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2, z + BLOCK_SIZE / 2); block.castShadow = true; block.receiveShadow = true; block.userData = { type: type }; scene.add(block); world[key] = { mesh: block, type: type }; if (broadcast) { broadcastMessage({ type: 'addBlock', id: peerId, position: { x, y, z }, blockType: type }); } }
        function removeBlock(x, y, z, broadcast = true) {  const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`; if (world[key]) { scene.remove(world[key].mesh); delete world[key]; if (broadcast) { broadcastMessage({ type: 'removeBlock', id: peerId, position: { x, y, z } }); } return true; } return false; }
        function getBlockAt(x, y, z) {  const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`; return world[key]; }
        function checkCollision(playerBox) {  for (let x = Math.floor(playerBox.min.x); x <= Math.floor(playerBox.max.x); x++) { for (let y = Math.floor(playerBox.min.y); y <= Math.floor(playerBox.max.y); y++) { for (let z = Math.floor(playerBox.min.z); z <= Math.floor(playerBox.max.z); z++) { const block = getBlockAt(x, y, z); if (block) { const blockBox = new THREE.Box3().setFromObject(block.mesh); if (playerBox.intersectsBox(blockBox)) { return true; } } } } } return false; }
        function setupLighting() {  const ambientLight = new THREE.AmbientLight(0xcccccc, 0.8); scene.add(ambientLight); const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.7 ); hemiLight.position.set( 0, 20, 0 ); scene.add( hemiLight ); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); directionalLight.position.set(50, 80, 30); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 10; directionalLight.shadow.camera.far = 200; directionalLight.shadow.camera.left = -60; directionalLight.shadow.camera.right = 60; directionalLight.shadow.camera.top = 60; directionalLight.shadow.camera.bottom = -60; scene.add(directionalLight); }
        function setupBlockHighlight() { const highlightGeometry = new THREE.BoxGeometry(BLOCK_SIZE * 1.01, BLOCK_SIZE * 1.01, BLOCK_SIZE * 1.01); highlightMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.7 }); highlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial); highlightMesh.visible = false; scene.add(highlightMesh); }
        function setupControls() { blocker.addEventListener('click', () => { if (document.body.requestPointerLock) { document.body.requestPointerLock().catch(err => {}); } }); document.addEventListener('pointerlockchange', lockChangeAlert, false); function lockChangeAlert() { pointerLocked = (document.pointerLockElement === document.body); if (pointerLocked) { blocker.style.display = 'none'; document.addEventListener("mousemove", onMouseMove, false); } else { blocker.style.display = 'flex'; document.removeEventListener("mousemove", onMouseMove, false); moveForward = moveBackward = moveLeft = moveRight = isJumpHeld = false; } } const onMouseMove = (event) => { if (!pointerLocked) return; const movementX = event.movementX || 0; const movementY = event.movementY || 0; camera.rotation.y -= movementX * MOUSE_SENSITIVITY; camera.rotation.x -= movementY * MOUSE_SENSITIVITY; camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x)); }; }
        function setupEventListeners() {  window.addEventListener('resize', onWindowResize, false); document.addEventListener('keydown', onKeyDown, false); document.addEventListener('keyup', onKeyUp, false); document.addEventListener('mousedown', onMouseDown, false); document.addEventListener('contextmenu', (e) => { if(pointerLocked) e.preventDefault(); }, false); }
        function onWindowResize() {  camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onKeyDown(event) {  if (!pointerLocked) return; switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = true; break; case 'KeyS': case 'ArrowDown': moveBackward = true; break; case 'KeyA': case 'ArrowLeft': moveLeft = true; break; case 'KeyD': case 'ArrowRight': moveRight = true; break; case 'Space': isJumpHeld = true; break; case 'Escape': if(document.pointerLockElement) document.exitPointerLock(); break; } }
        function onKeyUp(event) {  switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = false; break; case 'KeyS': case 'ArrowDown': moveBackward = false; break; case 'KeyA': case 'ArrowLeft': moveLeft = false; break; case 'KeyD': case 'ArrowRight': moveRight = false; break; case 'Space': isJumpHeld = false; break; } }
        function onMouseDown(event) {  if (!pointerLocked) return; const intersect = getIntersectingBlock(); if (!intersect) return; const blockMesh = intersect.object; const blockCenter = blockMesh.position; const normal = intersect.face.normal; if (event.button === 0) { const coords = { x: Math.round(blockCenter.x - BLOCK_SIZE/2), y: Math.round(blockCenter.y - BLOCK_SIZE/2), z: Math.round(blockCenter.z - BLOCK_SIZE/2) }; removeBlock(coords.x, coords.y, coords.z, true); } else if (event.button === 2) { const placePos = new THREE.Vector3(); intersect.point.addScaledVector(normal, -0.01); placePos.copy(intersect.point).addScaledVector(normal, BLOCK_SIZE * 0.51); const coords = { x: Math.floor(placePos.x), y: Math.floor(placePos.y), z: Math.floor(placePos.z) }; const playerFeetY = camera.position.y - PLAYER_HEIGHT; const playerHeadY = camera.position.y; const playerCenterY = (playerFeetY + playerHeadY) / 2; const playerBounds = new THREE.Box3().setFromCenterAndSize( new THREE.Vector3(camera.position.x, playerCenterY, camera.position.z), new THREE.Vector3(PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_WIDTH) ); const blockBB = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(coords.x + 0.5, coords.y + 0.5, coords.z + 0.5), new THREE.Vector3(1,1,1)); if (!playerBounds.intersectsBox(blockBB) && !getBlockAt(coords.x, coords.y, coords.z)) { addBlock(coords.x, coords.y, coords.z, 'stone', true); } } }
        function getIntersectingBlock() {  raycaster.setFromCamera({ x: 0, y: 0 }, camera); const worldMeshes = Object.values(world).map(b => b.mesh).filter(mesh => mesh); if (worldMeshes.length === 0) return null; const intersects = raycaster.intersectObjects(worldMeshes); for(let i = 0; i < intersects.length; i++) { if (intersects[i].distance <= REACH_DISTANCE) return intersects[i]; } return null; }

        function generateShortId(length = 6) { const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let result = ''; for (let i = 0; i < length; i++) { result += chars.charAt(Math.floor(Math.random() * chars.length)); } return result; }

        function setupPeerJSUI() {
            showHostBtn.onclick = () => { initialChoiceView.style.display = 'none'; hostView.style.display = 'block'; hostGame(); };
            showJoinBtn.onclick = () => { initialChoiceView.style.display = 'none'; joinView.style.display = 'block'; };
            joinBtn.onclick = joinGame;
            backBtns.forEach(btn => { btn.onclick = resetConnection; });
        }

        function hostGame() {
            isHost = true;
            statusEl.textContent = 'Generating Game ID...';
            hostIdDisplay.textContent = 'Generating...';
            const generatedId = generateShortId(6);
            peer = new Peer(generatedId);
            peer.on('open', id => { peerId = id; hostIdDisplay.textContent = id; statusEl.textContent = 'Waiting for players...'; playerStates[peerId] = { name: playerName, position: camera.position, rotation: camera.rotation }; });
            peer.on('connection', setupConnectionEvents);
            peer.on('error', err => { if (err.type === 'unavailable-id') { statusEl.textContent = `Error: Game ID taken. Try again.`; } else { statusEl.textContent = `Error: ${err.type}`; } resetConnection(); });
        }
        
        function joinGame() {
            const hostId = joinIdInput.value.trim().toUpperCase();
            if (!hostId) { alert('Please enter a Host ID.'); return; }
            isHost = false;
            joinBtn.disabled = true;
            joinView.querySelector('.backBtn').disabled = true;
            statusEl.textContent = 'Connecting...';
            peer = new Peer();
            peer.on('open', id => { peerId = id; const conn = peer.connect(hostId, { reliable: true }); setupConnectionEvents(conn); });
            peer.on('error', err => { statusEl.textContent = `Error: ${err.type}`; resetConnection(); });
        }

        function setupConnectionEvents(conn) {
            connections[conn.peer] = conn;
            conn.on('open', () => {
                playerNameInput.disabled = true;
                if (isHost) {
                    statusEl.textContent = `Player ${conn.peer} connected.`;
                } else {
                    statusEl.textContent = 'Connected! Handshaking...';
                    connectionInfoEl.style.display = 'none';
                    const initData = { type: 'init', id: peerId, name: playerName, position: camera.position, rotation: camera.rotation };
                    conn.send(JSON.stringify(initData));
                }
            });
            conn.on('data', data => { try { handleData(JSON.parse(data), conn.peer); } catch (e) {} });
            conn.on('close', () => { handleDisconnect(conn.peer); });
            conn.on('error', (err) => { statusEl.textContent = `Connection error.`; handleDisconnect(conn.peer); });
        }

        function handleDisconnect(disconnectedId) {
            statusEl.textContent = `Player ${disconnectedId} disconnected.`;
            removePeerRepresentation(disconnectedId);
            delete connections[disconnectedId];
            if (isHost) {
                delete playerStates[disconnectedId];
                broadcastMessage({ type: 'disconnect', id: disconnectedId });
            } else if (Object.keys(connections).length === 0) {
                resetConnection();
                statusEl.textContent = 'Disconnected from host.';
            }
            updatePlayerCount();
        }

        function resetConnection() {
            if (peer) peer.destroy();
            for (const pId in peers) removePeerRepresentation(pId);
            isHost = false;
            peer = null;
            connections = {};
            playerStates = {};
            
            hostView.style.display = 'none';
            joinView.style.display = 'none';
            initialChoiceView.style.display = 'block';
            connectionInfoEl.style.display = 'block';
            
            joinBtn.disabled = false;
            if (joinView.querySelector('.backBtn')) {
                joinView.querySelector('.backBtn').disabled = false;
            }
            playerNameInput.disabled = false;

            hostIdDisplay.textContent = 'Generating...';
            joinIdInput.value = '';
            statusEl.textContent = 'Ready';
            updatePlayerCount();
        }

        function broadcastMessage(data, originatorId = null) { if (!peer) return; const message = JSON.stringify(data); if (isHost) { for (const pId in connections) { if (pId !== originatorId && connections[pId].open) { connections[pId].send(message); } } } else { const hostConn = Object.values(connections)[0]; if (hostConn && hostConn.open) { hostConn.send(message); } } }
        function sendWorldState(conn) { if (!conn || !conn.open) return; const worldData = []; for (const key in world) { if (world[key]) { const [x, y, z] = key.split(',').map(Number); worldData.push({ p: { x, y, z }, t: world[key].type }); } } conn.send(JSON.stringify({ type: 'worldState', blocks: worldData })); }

        function createNameTag(text) { const fontface = "Arial"; const fontsize = 24; const padding = 10; const cornerRadius = 8; const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); context.font = `Bold ${fontsize}px ${fontface}`; const metrics = context.measureText(text); const textWidth = metrics.width; canvas.width = textWidth + padding * 2; canvas.height = fontsize + padding * 2; context.font = `Bold ${fontsize}px ${fontface}`; context.fillStyle = "rgba(0, 0, 0, 0.5)"; context.beginPath(); context.moveTo(cornerRadius, 0); context.lineTo(canvas.width - cornerRadius, 0); context.quadraticCurveTo(canvas.width, 0, canvas.width, cornerRadius); context.lineTo(canvas.width, canvas.height - cornerRadius); context.quadraticCurveTo(canvas.width, canvas.height, canvas.width - cornerRadius, canvas.height); context.lineTo(cornerRadius, canvas.height); context.quadraticCurveTo(0, canvas.height, 0, canvas.height - cornerRadius); context.lineTo(0, cornerRadius); context.quadraticCurveTo(0, 0, cornerRadius, 0); context.closePath(); context.fill(); context.fillStyle = "rgba(255, 255, 255, 1.0)"; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(text, canvas.width / 2, canvas.height / 2); const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; const spriteMaterial = new THREE.SpriteMaterial({ map: texture }); const sprite = new THREE.Sprite(spriteMaterial); const aspect = canvas.width / canvas.height; sprite.scale.set(aspect * 0.4, 0.4, 1.0); return sprite; }
        function createPlayerModel(name = "Player") { const playerGroup = new THREE.Group(); const headSize = PLAYER_WIDTH * 0.8; const torsoHeight = PLAYER_HEIGHT * 0.5; const torsoWidth = PLAYER_WIDTH; const torsoDepth = PLAYER_WIDTH * 0.6; const limbWidth = PLAYER_WIDTH * 0.3; const armHeight = torsoHeight * 0.9; const legHeight = PLAYER_HEIGHT - torsoHeight - headSize; const eyeSize = headSize * 0.18; const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFCC99 }); const torsoMaterial = new THREE.MeshLambertMaterial({ color: 0x0088FF }); const limbMaterial = new THREE.MeshLambertMaterial({ color: 0x333399 }); const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 }); const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize); const torsoGeo = new THREE.BoxGeometry(torsoWidth, torsoHeight, torsoDepth); const armGeo = new THREE.BoxGeometry(limbWidth, armHeight, limbWidth); const legGeo = new THREE.BoxGeometry(limbWidth, legHeight, limbWidth); const eyeGeo = new THREE.BoxGeometry(eyeSize, eyeSize, eyeSize); const head = new THREE.Mesh(headGeo, headMaterial); const torso = new THREE.Mesh(torsoGeo, torsoMaterial); const leftArm = new THREE.Mesh(armGeo, limbMaterial); const rightArm = new THREE.Mesh(armGeo, limbMaterial); const leftLeg = new THREE.Mesh(legGeo, limbMaterial); const rightLeg = new THREE.Mesh(legGeo, limbMaterial); const leftEye = new THREE.Mesh(eyeGeo, eyeMaterial); const rightEye = new THREE.Mesh(eyeGeo, eyeMaterial); leftLeg.position.set(-torsoWidth / 2 + limbWidth / 2, legHeight / 2, 0); rightLeg.position.set(torsoWidth / 2 - limbWidth / 2, legHeight / 2, 0); torso.position.set(0, legHeight + torsoHeight / 2, 0); head.position.set(0, legHeight + torsoHeight + headSize / 2, 0); leftArm.position.set(-torsoWidth / 2 - limbWidth / 2, legHeight + torsoHeight - armHeight / 2, 0); rightArm.position.set(torsoWidth / 2 + limbWidth / 2, legHeight + torsoHeight - armHeight / 2, 0); const eyeOffsetZ = -headSize / 2 + eyeSize / 3; const eyeOffsetX = headSize * 0.25; const eyeOffsetY = headSize * 0.1; leftEye.position.set(-eyeOffsetX, eyeOffsetY, eyeOffsetZ); rightEye.position.set(eyeOffsetX, eyeOffsetY, eyeOffsetZ); head.add(leftEye); head.add(rightEye); head.name = 'playerHead'; playerGroup.add(head); playerGroup.add(torso); playerGroup.add(leftArm); playerGroup.add(rightArm); playerGroup.add(leftLeg); playerGroup.add(rightLeg); const nameTag = createNameTag(name); const headTopY = legHeight + torsoHeight + headSize; nameTag.position.set(0, headTopY + 0.3, 0); playerGroup.add(nameTag); playerGroup.traverse((child) => { if (child instanceof THREE.Mesh) { child.castShadow = true; child.receiveShadow = true; } }); playerGroup.rotation.order = 'YXZ'; return playerGroup; }
        function addPeerRepresentation(id, name, position, rotation) { if (peers[id] || id === peerId) return; const playerModel = createPlayerModel(name); playerModel.position.set(position.x, position.y - PLAYER_HEIGHT, position.z); if(rotation) { playerModel.rotation.y = rotation._y; const head = playerModel.getObjectByName('playerHead'); if (head) { head.rotation.x = rotation._x; } } peers[id] = { object: playerModel, name: name, lastUpdate: Date.now() }; scene.add(playerModel); updatePlayerCount(); }
        
        function handleData(message, senderId) {
            if (isHost) {
                switch(message.type) {
                    case 'init':
                        playerStates[senderId] = { name: message.name, position: message.position, rotation: message.rotation };
                        addPeerRepresentation(senderId, message.name, message.position, message.rotation); 
                        connections[senderId].send(JSON.stringify({ type: 'syncPlayers', players: playerStates }));
                        broadcastMessage({ type: 'newPlayer', id: senderId, name: message.name, position: message.position, rotation: message.rotation }, senderId);
                        sendWorldState(connections[senderId]);
                        updatePlayerCount();
                        break;
                    case 'update':
                        if (playerStates[senderId]) {
                            playerStates[senderId].position = message.position;
                            playerStates[senderId].rotation = message.rotation;
                            updatePeerRepresentation(senderId, message.position, message.rotation);
                            broadcastMessage(message, senderId);
                        }
                        break;
                    case 'addBlock':
                    case 'removeBlock':
                        broadcastMessage(message, senderId);
                        if(message.type === 'addBlock') addBlock(message.position.x, message.position.y, message.position.z, message.blockType, false);
                        else removeBlock(message.position.x, message.position.y, message.position.z, false);
                        break;
                }
                return;
            }

            if (message.id === peerId && message.type !== 'syncPlayers') return;

            switch (message.type) {
                case 'syncPlayers': 
                    Object.entries(message.players).forEach(([pId, state]) => addPeerRepresentation(pId, state.name, state.position, state.rotation));
                    statusEl.textContent = 'Game Joined!';
                    break;
                case 'newPlayer':
                    addPeerRepresentation(message.id, message.name, message.position, message.rotation);
                    break;
                case 'worldState': 
                    message.blocks.forEach(blockData => addBlock(blockData.p.x, blockData.p.y, blockData.p.z, blockData.t, false)); 
                    break;
                case 'update': 
                    updatePeerRepresentation(message.id, message.position, message.rotation); 
                    break;
                case 'addBlock': 
                    addBlock(message.position.x, message.position.y, message.position.z, message.blockType, false); 
                    break;
                case 'removeBlock': 
                    removeBlock(message.position.x, message.position.y, message.position.z, false); 
                    break;
                case 'disconnect': 
                    removePeerRepresentation(message.id); 
                    break;
            }
        }

        function updatePeerRepresentation(id, position, rotation) { if (!peers[id]) { addPeerRepresentation(id, "Player...", position, rotation); } else if (peers[id].object) { const playerModel = peers[id].object; const targetPos = new THREE.Vector3( position.x, position.y - PLAYER_HEIGHT, position.z ); playerModel.position.lerp(targetPos, 0.3); if(rotation) { playerModel.rotation.y = rotation._y; const head = playerModel.getObjectByName('playerHead'); if (head) { head.rotation.x = rotation._x; } } peers[id].lastUpdate = Date.now(); } }
        function removePeerRepresentation(id) { if (peers[id] && peers[id].object) { scene.remove(peers[id].object); } delete peers[id]; updatePlayerCount(); }
        function updatePlayerCount() { const count = Object.keys(playerStates).length > 0 ? Object.keys(playerStates).length : 1 + Object.keys(peers).length; playersEl.textContent = `Players: ${count}`; }

        function animate() { requestAnimationFrame(animate); const delta = Math.min(clock.getDelta(), 0.1); if (pointerLocked) { updatePlayerMovement(delta); updateBlockHighlight(); } updatePeers(delta); try { if (renderer && scene && camera) renderer.render(scene, camera); } catch (e) {} }
        function updatePlayerMovement(delta) { const moveSpeed = PLAYER_SPEED; playerVelocity.y -= GRAVITY_ACCELERATION * delta; if (isJumpHeld && isOnGround) { playerVelocity.y = JUMP_VELOCITY; isOnGround = false; } const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize(); const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize(); let intendedVelocityX = 0; let intendedVelocityZ = 0; if (moveForward) { intendedVelocityX += forward.x; intendedVelocityZ += forward.z; } if (moveBackward) { intendedVelocityX -= forward.x; intendedVelocityZ -= forward.z; } if (moveLeft) { intendedVelocityX -= right.x; intendedVelocityZ -= right.z; } if (moveRight) { intendedVelocityX += right.x; intendedVelocityZ += right.z; } const horizontalMagnitude = Math.sqrt(intendedVelocityX * intendedVelocityX + intendedVelocityZ * intendedVelocityZ); if (horizontalMagnitude > 0) { playerVelocity.x = (intendedVelocityX / horizontalMagnitude) * moveSpeed; playerVelocity.z = (intendedVelocityZ / horizontalMagnitude) * moveSpeed; } else { playerVelocity.x = 0; playerVelocity.z = 0; } const playerHalfWidth = PLAYER_WIDTH / 2; const playerHalfDepth = PLAYER_WIDTH / 2; const feetLevelOffset = -PLAYER_HEIGHT; const eyeLevelOffset = 0.01; const deltaMovement = playerVelocity.clone().multiplyScalar(delta); isOnGround = false; const currentYPos = camera.position.y; const nextYPos = currentYPos + deltaMovement.y; const playerBoxY = new THREE.Box3(); playerBoxY.min.set(camera.position.x - playerHalfWidth, nextYPos + feetLevelOffset, camera.position.z - playerHalfDepth); playerBoxY.max.set(camera.position.x + playerHalfWidth, nextYPos + eyeLevelOffset, camera.position.z + playerHalfDepth); if (checkCollision(playerBoxY)) { if (playerVelocity.y <= 0) { let highestGroundY = -Infinity; for (let y = Math.floor(playerBoxY.min.y); y <= Math.floor(playerBoxY.max.y); y++) { for (let x = Math.floor(playerBoxY.min.x); x <= Math.floor(playerBoxY.max.x); x++) { for (let z = Math.floor(playerBoxY.min.z); z <= Math.floor(playerBoxY.max.z); z++) { if (getBlockAt(x, y, z)) { highestGroundY = Math.max(highestGroundY, y + 1); } } } } if (highestGroundY > -Infinity) { camera.position.y = highestGroundY + PLAYER_HEIGHT; playerVelocity.y = 0; isOnGround = true; } else { camera.position.y = currentYPos; playerVelocity.y = 0; } } else if (playerVelocity.y > 0) { let lowestCeilingY = Infinity; for (let y = Math.floor(playerBoxY.min.y); y <= Math.floor(playerBoxY.max.y); y++) { for (let x = Math.floor(playerBoxY.min.x); x <= Math.floor(playerBoxY.max.x); x++) { for (let z = Math.floor(playerBoxY.min.z); z <= Math.floor(playerBoxY.max.z); z++) { if (getBlockAt(x, y, z)) { lowestCeilingY = Math.min(lowestCeilingY, y); } } } } if (lowestCeilingY < Infinity) { camera.position.y = lowestCeilingY - eyeLevelOffset; playerVelocity.y = 0; } else { camera.position.y = currentYPos; playerVelocity.y = 0; } } } else { camera.position.y = nextYPos; } const currentXPos = camera.position.x; const nextXPos = currentXPos + deltaMovement.x; const playerBoxX = new THREE.Box3(); playerBoxX.min.set(nextXPos - playerHalfWidth, camera.position.y + feetLevelOffset, camera.position.z - playerHalfDepth); playerBoxX.max.set(nextXPos + playerHalfWidth, camera.position.y + eyeLevelOffset, camera.position.z + playerHalfDepth); if (checkCollision(playerBoxX)) { playerVelocity.x = 0; if (deltaMovement.x > 0) camera.position.x = Math.floor(nextXPos + playerHalfWidth) - playerHalfWidth - 0.01; else if (deltaMovement.x < 0) camera.position.x = Math.floor(nextXPos - playerHalfWidth) + 1 + playerHalfWidth + 0.01; } else { camera.position.x = nextXPos; } const currentZPos = camera.position.z; const nextZPos = currentZPos + deltaMovement.z; const playerBoxZ = new THREE.Box3(); playerBoxZ.min.set(camera.position.x - playerHalfWidth, camera.position.y + feetLevelOffset, nextZPos - playerHalfDepth); playerBoxZ.max.set(camera.position.x + playerHalfWidth, camera.position.y + eyeLevelOffset, nextZPos + playerHalfDepth); if (checkCollision(playerBoxZ)) { playerVelocity.z = 0; if (deltaMovement.z > 0) camera.position.z = Math.floor(nextZPos + playerHalfDepth) - playerHalfDepth - 0.01; else if (deltaMovement.z < 0) camera.position.z = Math.floor(nextZPos - playerHalfDepth) + 1 + playerHalfDepth + 0.01; } else { camera.position.z = nextZPos; } if (camera.position.y < -10) { camera.position.set(0, WORLD_HEIGHT + PLAYER_HEIGHT + 2, 0); playerVelocity.set(0,0,0); isOnGround = false; } }
        function updateBlockHighlight() {  const intersect = getIntersectingBlock(); if (intersect) { const highlightPos = intersect.object.position.clone(); highlightMesh.position.copy(highlightPos); highlightMesh.visible = true; } else { highlightMesh.visible = false; } }
        const updateInterval = 100;
        function updatePeers(delta) {
            const now = Date.now();
            if (peer && (Object.keys(connections).length > 0) && (now - lastUpdateTime > updateInterval)) {
                const myUpdate = { type: 'update', id: peerId, position: camera.position, rotation: { _x: camera.rotation.x, _y: camera.rotation.y, _z: camera.rotation.z } };
                broadcastMessage(myUpdate);
                if (isHost) {
                    playerStates[peerId] = { name: playerName, position: camera.position, rotation: camera.rotation };
                }
                lastUpdateTime = now;
            }
        }

        document.addEventListener('DOMContentLoaded', (event) => { try { init(); } catch (error) { document.getElementById('status').textContent = "Initialization Error! Check Console."; if (blocker) blocker.style.display = 'flex'; if (document.getElementById('blockerInstructions')) document.getElementById('blockerInstructions').innerHTML = `<h2>Error!</h2><p>Game failed to initialize...</p><p>${error.message}</p>`; } });

    </script>
</body>

</html>
