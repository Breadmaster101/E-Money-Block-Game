<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Money Block Game Alpha v2.1</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: Arial, sans-serif; color: #333; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; max-width: 380px; border: 1px solid #bbb; box-shadow: 0 4px 8px rgba(0,0,0,0.2); z-index: 20; }
        #blocker { position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.75); display: flex; justify-content: center; align-items: center; color: white; z-index: 10; }
        #instructions { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 4px; font-size: 0.9em; color: white; z-index: 5; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background-color: white; transform: translate(-50%, -50%); border-radius: 0px; mix-blend-mode: difference; border: 1px solid black; z-index: 5;}
        #connectionInfo { margin-top: 10px; }
        textarea { width: 100%; min-height: 60px; margin-top: 5px; box-sizing: border-box; background: #f8f8f8; color: #333; border: 1px solid #ccc; font-size: 0.85em; padding: 5px; }
        button { margin-top: 8px; padding: 10px 15px; cursor: pointer; background: #5cb85c; color: white; border: none; border-radius: 5px; font-size: 0.95em; transition: background-color 0.2s ease; }
        button:hover { background: #4cae4c; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #inviteLink { margin-top: 5px; background: #e9e9e9; padding: 8px; border: 1px dashed #ccc; word-wrap: break-word; font-size: 0.8em; max-height: 60px; overflow-y: auto; }
        label { display: block; margin-top: 10px; font-weight: bold; font-size: 0.9em; }
        #blockerInstructions { width: 80%; max-width: 450px; background: #333; padding: 25px; border-radius: 10px; text-align: center; border: 1px solid #555; }
        h2, h3 { margin-top: 0; color: #eee; }
        hr { border: 0; height: 1px; background: #555; margin: 15px 0; }
        strong { color: #444; }
    </style>
</head>
<body>
     <div id="blocker"> <div id="blockerInstructions"> <h2>E-Money Block Game Alpha v2.1</h2> <p>Click anywhere to start playing!</p> <p>(Requires Pointer Lock)</p <hr> <h3>Controls:</h3> <p>W/A/S/D: Move | Space: Jump (Hold for continuous)</p> <p>Mouse: Look | Left Click: Destroy Block | Right Click: Place Block</p> <p>ESC: Release Mouse</p> <hr> <p>Use the UI (Top Left) to connect...</p> </div> </div>
     <div id="ui"> <div><strong>Status:</strong> <span id="status">Initializing...</span></div> <div id="players">Players: 1</div> <div id="connectionInfo"> <hr> <button id="createInviteBtn">1. Create Invite Link</button> <div id="inviteLinkContainer" style="display:none;"> <label>Send this link to friend:</label> <div id="inviteLink"></div> <label for="answerInputArea">2. Paste their Answer here:</label> <textarea id="answerInputArea" placeholder="Paste Answer data from friend here"></textarea> <button id="submitAnswerBtn">3. Submit Answer</button> </div> <div id="joinGameContainer" style="display:none;"> <label for="offerDisplayArea">Offer Received (from link):</label> <textarea id="offerDisplayArea" readonly></textarea> <button id="createAnswerBtn">1. Create Answer</button> <label for="answerOutputArea" style="display:none;">2. Copy this Answer...</label> <textarea id="answerOutputArea" style="display:none;" readonly></textarea> </div> </div> </div>
     <div id="instructions"> W/A/S/D: Move | Space: Jump (Hold) | Mouse: Look | LClick: Destroy | RClick: Place | ESC: Unlock Mouse </div>
     <div id="crosshair"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>

    <script>
        const PLAYER_HEIGHT = 1.5; const PLAYER_WIDTH = 0.6; const PLAYER_SPEED = 5.0; const MOUSE_SENSITIVITY = 0.002;
        const BLOCK_SIZE = 1; const WORLD_SIZE_X = 20; const WORLD_SIZE_Z = 20; const WORLD_HEIGHT = 8; const REACH_DISTANCE = 6;
        const GRAVITY_ACCELERATION = 25.0; const JUMP_VELOCITY = 8.0;

        let scene, camera, renderer; let world = {}; let playerVelocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let isJumpHeld = false; let isOnGround = false;
        let peer; let peers = {}; let peerId; let clock = new THREE.Clock(); let raycaster = new THREE.Raycaster();
        let blockGeometry; let blockMaterials = {}; let textures = {}; let highlightMaterial, highlightMesh;
        let pointerLocked = false;
        let lastUpdateTime = 0;

        const blocker = document.getElementById('blocker'); const statusEl = document.getElementById('status'); const createInviteBtn = document.getElementById('createInviteBtn'); const inviteLinkContainer = document.getElementById('inviteLinkContainer'); const inviteLinkEl = document.getElementById('inviteLink'); const answerInputArea = document.getElementById('answerInputArea'); const submitAnswerBtn = document.getElementById('submitAnswerBtn'); const joinGameContainer = document.getElementById('joinGameContainer'); const offerDisplayArea = document.getElementById('offerDisplayArea'); const createAnswerBtn = document.getElementById('createAnswerBtn'); const answerOutputArea = document.getElementById('answerOutputArea'); const answerOutputLabel = document.querySelector('label[for="answerOutputArea"]'); const playersEl = document.getElementById('players');

        function init() { console.log("init() started..."); peerId = 'user_' + Math.random().toString(36).substring(2, 9); console.log("My Peer ID:", peerId); setupScene(); setupPlayer(); setupLighting(); setupBlockGeometry(); setupTexturesAndMaterials(); setupWorld(); setupBlockHighlight(); setupControls(); setupEventListeners(); setupWebRTCUI(); checkUrlForOffer(); console.log("init() finished."); animate(); }
        function setupScene() {  scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 10, 150); camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; document.body.appendChild(renderer.domElement); console.log("setupScene() complete."); }
        function setupPlayer() {  camera.position.set(0, WORLD_HEIGHT + PLAYER_HEIGHT + 2, 5); camera.rotation.order = 'YXZ'; console.log("setupPlayer() complete."); }
        function setupBlockGeometry() {  blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); console.log("Block geometry created."); }
        function setupTexturesAndMaterials() {  blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE); console.log("Creating textures programmatically via Canvas..."); const textureSize = 16; function createCanvasTexture(drawFunction) { const canvas = document.createElement('canvas'); canvas.width = textureSize; canvas.height = textureSize; const context = canvas.getContext('2d'); drawFunction(context, textureSize); const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter; texture.needsUpdate = true; return texture; } function drawDirt(ctx, size) { ctx.fillStyle = '#8B4513'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = 'rgba(0,0,0,0.1)'; for (let i=0; i < size*size*0.3; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); } function drawStone(ctx, size) { ctx.fillStyle = '#808080'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = 'rgba(0,0,0,0.15)'; for (let i=0; i < size*size*0.4; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); ctx.fillStyle = 'rgba(255,255,255,0.1)'; for (let i=0; i < size*size*0.2; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); } function drawGrassTop(ctx, size) { ctx.fillStyle = '#5a9a5a'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = 'rgba(0,0,0,0.1)'; for (let i=0; i < size*size*0.3; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); ctx.fillStyle = 'rgba(255,255,255,0.05)'; for (let i=0; i < size*size*0.2; ++i) ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1); } function drawGrassSide(ctx, size) { ctx.fillStyle = '#5a9a5a'; ctx.fillRect(0, 0, size, size * 0.25); ctx.fillStyle = '#8B4513'; ctx.fillRect(0, size * 0.25, size, size * 0.75); ctx.fillStyle = 'rgba(0,0,0,0.1)'; for (let i=0; i < size*size*0.75*0.3; ++i) ctx.fillRect(Math.random()*size, size*0.25 + Math.random()*size*0.75, 1, 1); } textures = { grassTop: createCanvasTexture(drawGrassTop), grassSide: createCanvasTexture(drawGrassSide), dirt: createCanvasTexture(drawDirt), stone: createCanvasTexture(drawStone) }; console.log("Canvas textures created."); console.log("Creating final block materials from canvas textures..."); blockMaterials = { grass: [ new THREE.MeshLambertMaterial({ map: textures.grassSide }), new THREE.MeshLambertMaterial({ map: textures.grassSide }), new THREE.MeshLambertMaterial({ map: textures.grassTop }), new THREE.MeshLambertMaterial({ map: textures.dirt }), new THREE.MeshLambertMaterial({ map: textures.grassSide }), new THREE.MeshLambertMaterial({ map: textures.grassSide }) ], dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }), stone: new THREE.MeshLambertMaterial({ map: textures.stone }), }; blockMaterials.fallback = new THREE.MeshLambertMaterial({ color: 0xff00ff }); console.log("Canvas-based materials created and assigned."); }
        function setupWorld() {  console.log("Generating world terrain (using final canvas materials)..."); for (let x = -WORLD_SIZE_X / 2; x < WORLD_SIZE_X / 2; x++) { for (let z = -WORLD_SIZE_Z / 2; z < WORLD_SIZE_Z / 2; z++) { for (let y = 0; y < WORLD_HEIGHT; y++) { let blockType; if (y === WORLD_HEIGHT - 1) blockType = 'grass'; else if (y >= WORLD_HEIGHT - 4 && y < WORLD_HEIGHT -1) blockType = 'dirt'; else blockType = 'stone'; addBlock(x, y, z, blockType, false); } } } console.log("World terrain generation complete."); console.log("setupWorld() complete."); }
        function addBlock(x, y, z, type, broadcast = true) {  const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`; if (world[key]) return; let material = blockMaterials[type] || blockMaterials.fallback; if (!material) { console.error(`FATAL: No material found for type "${type}" or fallback!`); material = blockMaterials.fallback || new THREE.MeshLambertMaterial({color: 0xff00ff}); } const block = new THREE.Mesh(blockGeometry, material); block.position.set(x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2, z + BLOCK_SIZE / 2); block.castShadow = true; block.receiveShadow = true; block.userData = { type: type }; scene.add(block); world[key] = { mesh: block, type: type }; if (broadcast && peer && peer.connected) { sendData({ type: 'addBlock', id: peerId, position: { x, y, z }, blockType: type }); } }
        function removeBlock(x, y, z, broadcast = true) {  const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`; if (world[key]) { scene.remove(world[key].mesh); delete world[key]; if (broadcast && peer && peer.connected) { sendData({ type: 'removeBlock', id: peerId, position: { x, y, z } }); } return true; } return false; }
        function getBlockAt(x, y, z) {  const key = `${Math.floor(x)},${Math.floor(y)},${Math.floor(z)}`; return world[key]; }
        function checkCollision(playerBox) {  for (let x = Math.floor(playerBox.min.x); x <= Math.floor(playerBox.max.x); x++) { for (let y = Math.floor(playerBox.min.y); y <= Math.floor(playerBox.max.y); y++) { for (let z = Math.floor(playerBox.min.z); z <= Math.floor(playerBox.max.z); z++) { const block = getBlockAt(x, y, z); if (block) { const blockBox = new THREE.Box3().setFromObject(block.mesh); if (playerBox.intersectsBox(blockBox)) { return true; } } } } } return false; }
        function setupLighting() {  const ambientLight = new THREE.AmbientLight(0xcccccc, 0.8); scene.add(ambientLight); const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.7 ); hemiLight.position.set( 0, 20, 0 ); scene.add( hemiLight ); const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); directionalLight.position.set(50, 80, 30); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; directionalLight.shadow.camera.near = 10; directionalLight.shadow.camera.far = 200; directionalLight.shadow.camera.left = -60; directionalLight.shadow.camera.right = 60; directionalLight.shadow.camera.top = 60; directionalLight.shadow.camera.bottom = -60; scene.add(directionalLight); console.log("Lighting Setup Complete."); console.log("setupLighting() complete."); }

        function setupBlockHighlight() {
            const highlightGeometry = new THREE.BoxGeometry(BLOCK_SIZE * 1.01, BLOCK_SIZE * 1.01, BLOCK_SIZE * 1.01);
            highlightMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.7 }); // Black color
            highlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
            highlightMesh.visible = false; scene.add(highlightMesh);
            console.log("setupBlockHighlight() complete.");
        }

        function setupControls() {  blocker.addEventListener('click', () => { if (document.body.requestPointerLock) document.body.requestPointerLock(); else console.error("Pointer Lock API not supported/enabled."); }); document.addEventListener('pointerlockchange', lockChangeAlert, false); document.addEventListener('mozpointerlockchange', lockChangeAlert, false); document.addEventListener('webkitpointerlockchange', lockChangeAlert, false); function lockChangeAlert() { pointerLocked = (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body || document.webkitPointerLockElement === document.body); if (pointerLocked) { console.log('Pointer Lock engaged'); blocker.style.display = 'none'; document.addEventListener("mousemove", onMouseMove, false); } else { console.log('Pointer Lock released'); blocker.style.display = 'flex'; document.removeEventListener("mousemove", onMouseMove, false); moveForward = moveBackward = moveLeft = moveRight = isJumpHeld = false; } } const onMouseMove = (event) => { if (!pointerLocked) return; const movementX = event.movementX || 0; const movementY = event.movementY || 0; camera.rotation.y -= movementX * MOUSE_SENSITIVITY; camera.rotation.x -= movementY * MOUSE_SENSITIVITY; camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x)); }; console.log("setupControls() complete."); }
        function setupEventListeners() {  window.addEventListener('resize', onWindowResize, false); document.addEventListener('keydown', onKeyDown, false); document.addEventListener('keyup', onKeyUp, false); document.addEventListener('mousedown', onMouseDown, false); document.addEventListener('contextmenu', (e) => { if(pointerLocked) e.preventDefault(); }, false); console.log("setupEventListeners() complete."); }
        function onWindowResize() {  camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onKeyDown(event) {  if (!pointerLocked) return; switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = true; break; case 'KeyS': case 'ArrowDown': moveBackward = true; break; case 'KeyA': case 'ArrowLeft': moveLeft = true; break; case 'KeyD': case 'ArrowRight': moveRight = true; break; case 'Space': isJumpHeld = true; break; case 'Escape': if(document.pointerLockElement) document.exitPointerLock(); break; } }
        function onKeyUp(event) {  switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = false; break; case 'KeyS': case 'ArrowDown': moveBackward = false; break; case 'KeyA': case 'ArrowLeft': moveLeft = false; break; case 'KeyD': case 'ArrowRight': moveRight = false; break; case 'Space': isJumpHeld = false; break; } }
        function onMouseDown(event) {  if (!pointerLocked) return; const intersect = getIntersectingBlock(); if (!intersect) return; const blockMesh = intersect.object; const blockCenter = blockMesh.position; const normal = intersect.face.normal; if (event.button === 0) { const coords = { x: Math.round(blockCenter.x - BLOCK_SIZE/2), y: Math.round(blockCenter.y - BLOCK_SIZE/2), z: Math.round(blockCenter.z - BLOCK_SIZE/2) }; removeBlock(coords.x, coords.y, coords.z, true); } else if (event.button === 2) { const placePos = new THREE.Vector3(); intersect.point.addScaledVector(normal, -0.01); placePos.copy(intersect.point).addScaledVector(normal, BLOCK_SIZE * 0.51); const coords = { x: Math.floor(placePos.x), y: Math.floor(placePos.y), z: Math.floor(placePos.z) }; const playerFeetY = camera.position.y - PLAYER_HEIGHT; const playerHeadY = camera.position.y; const playerCenterY = (playerFeetY + playerHeadY) / 2; const playerBounds = new THREE.Box3().setFromCenterAndSize( new THREE.Vector3(camera.position.x, playerCenterY, camera.position.z), new THREE.Vector3(PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_WIDTH) ); const blockBB = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(coords.x + 0.5, coords.y + 0.5, coords.z + 0.5), new THREE.Vector3(1,1,1)); if (!playerBounds.intersectsBox(blockBB) && !getBlockAt(coords.x, coords.y, coords.z)) { addBlock(coords.x, coords.y, coords.z, 'stone', true); } else { console.log("Cannot place block: Collision with player or existing block."); } } }
        function getIntersectingBlock() {  raycaster.setFromCamera({ x: 0, y: 0 }, camera); const worldMeshes = Object.values(world).map(b => b.mesh).filter(mesh => mesh); if (worldMeshes.length === 0) return null; const intersects = raycaster.intersectObjects(worldMeshes); for(let i = 0; i < intersects.length; i++) { if (intersects[i].distance <= REACH_DISTANCE) return intersects[i]; } return null; }

        function checkUrlForOffer() {  const hash = window.location.hash.substring(1); if (hash.startsWith('offer=')) { const encodedOffer = hash.substring(6); try { const offerJson = atob(encodedOffer); const offer = JSON.parse(offerJson); console.log("Received offer from URL:", offer); offerDisplayArea.value = offerJson; joinGameContainer.style.display = 'block'; createInviteBtn.style.display = 'none'; statusEl.textContent = "Offer Received. Create Answer."; startPeer(false); if (peer) { peer.signal(offer); } else { console.error("Peer object not created before signaling in checkUrlForOffer"); statusEl.textContent = "Error: Peer setup failed."; } } catch (err) { console.error("Error decoding/parsing offer from URL:", err); statusEl.textContent = "Error: Invalid invite link."; resetConnectionUI(true); } } else { console.log("No offer found in URL hash."); resetConnectionUI(true); } console.log("checkUrlForOffer() complete."); }
        function setupWebRTCUI() {  createInviteBtn.onclick = () => { console.log("Create Invite Link button clicked."); startPeer(true); createInviteBtn.disabled = true; statusEl.textContent = "Creating offer..."; }; createAnswerBtn.onclick = () => { console.log("Create Answer button clicked."); createAnswerBtn.disabled = true; statusEl.textContent = "Generating Answer..."; }; submitAnswerBtn.onclick = () => { console.log("Submit Answer button clicked."); const answerJson = answerInputArea.value.trim(); if (answerJson && peer) { try { peer.signal(JSON.parse(answerJson)); submitAnswerBtn.disabled = true; answerInputArea.disabled = true; statusEl.textContent = "Answer submitted, connecting..."; } catch (err) { console.error("Error parsing answer:", err); alert("Invalid answer JSON."); statusEl.textContent = "Error: Invalid Answer format."; submitAnswerBtn.disabled = false; answerInputArea.disabled = false; } } else { alert("Paste the Answer signal data first."); } }; console.log("setupWebRTCUI() complete."); }
        function startPeer(initiator = false) {  console.log(`startPeer() called. Initiator: ${initiator}`); if (peer) { console.log("Destroying existing peer connection before creating new one."); peer.destroy(); peer = null; } statusEl.textContent = 'Initializing Peer...'; try { peer = new SimplePeer({ initiator: initiator, trickle: false, }); console.log("SimplePeer object created."); peer.on('error', err => { console.error('Peer Error:', err); statusEl.textContent = `Error: ${err.message}`; resetConnectionUI(); }); peer.on('signal', data => { console.log(`peer.on('signal') fired. Signal type: ${data.type}`); const signalDataJson = JSON.stringify(data); console.log('SIGNAL data:', signalDataJson); if (data.type === 'offer') { const encodedOffer = btoa(signalDataJson); const inviteUrl = window.location.origin + window.location.pathname + '#offer=' + encodedOffer; inviteLinkEl.textContent = inviteUrl; inviteLinkContainer.style.display = 'block'; statusEl.textContent = 'Invite link created. Send it and wait for answer.'; console.log("Offer generated and UI updated."); } else if (data.type === 'answer') { answerOutputArea.value = signalDataJson; answerOutputArea.style.display = 'block'; answerOutputLabel.style.display = 'block'; statusEl.textContent = 'Answer created. Copy it and send back.'; console.log("Answer generated and UI updated."); } }); peer.on('connect', () => { console.log('CONNECT event fired.'); statusEl.textContent = 'Connected!'; document.getElementById('connectionInfo').style.display = 'none'; sendData({ type: 'init', id: peerId, position: camera.position, rotation: camera.rotation }); sendWorldState(); }); peer.on('data', data => { try { const message = JSON.parse(data.toString()); handleData(message); } catch (err) { console.error("Failed to parse received data:", data.toString(), err); } }); peer.on('close', () => { console.log('CLOSE event fired.'); statusEl.textContent = 'Disconnected'; resetConnectionUI(); for (const pId in peers) removePeerRepresentation(pId); }); } catch (error) { console.error("Error creating SimplePeer object:", error); statusEl.textContent = "Error: Failed to initialize WebRTC."; resetConnectionUI(); } }
        function resetConnectionUI(isInitial = false) {  statusEl.textContent = isInitial ? 'Ready' : 'Disconnected'; console.log(`resetConnectionUI called. isInitial: ${isInitial}, Status set to: ${statusEl.textContent}`); inviteLinkContainer.style.display = 'none'; joinGameContainer.style.display = 'none'; createInviteBtn.style.display = 'block'; createInviteBtn.disabled = false; answerInputArea.value = ''; answerInputArea.disabled = false; submitAnswerBtn.disabled = false; offerDisplayArea.value = ''; createAnswerBtn.disabled = false; answerOutputArea.value = ''; answerOutputArea.style.display = 'none'; answerOutputLabel.style.display = 'none'; if (!isInitial && window.location.hash) { console.log("Clearing URL hash."); history.pushState("", document.title, window.location.pathname + window.location.search); } if (peer) { console.log("Destroying peer object in resetConnectionUI."); peer.destroy(); peer = null; } const currentPeers = Object.keys(peers); if(currentPeers.length > 0) { console.log("Removing peer representations in resetConnectionUI."); for (const pId in peers) removePeerRepresentation(pId); } updatePlayerCount(); }
        function sendData(data) {  if (peer && peer.connected) { try { peer.send(JSON.stringify(data)); } catch (err) { console.error("Error sending data:", err, data); } } }
        function sendWorldState() {  if (!peer || !peer.connected) return; console.log("Sending initial world state..."); const worldData = []; for (const key in world) { if (world[key]) { const [x, y, z] = key.split(',').map(Number); worldData.push({ p: { x, y, z }, t: world[key].type }); } } const chunkSize = 50; for (let i = 0; i < worldData.length; i += chunkSize) { const chunk = worldData.slice(i, i + chunkSize); sendData({ type: 'worldStateChunk', id: peerId, blocks: chunk }); } sendData({ type: 'worldStateEnd', id: peerId }); console.log(`Sent world state in ${Math.ceil(worldData.length/chunkSize)} chunks.`); }


        function createPlayerModel() {
            const playerGroup = new THREE.Group();
            const headSize = PLAYER_WIDTH * 0.8; const torsoHeight = PLAYER_HEIGHT * 0.5; const torsoWidth = PLAYER_WIDTH; const torsoDepth = PLAYER_WIDTH * 0.6; const limbWidth = PLAYER_WIDTH * 0.3; const armHeight = torsoHeight * 0.9; const legHeight = PLAYER_HEIGHT - torsoHeight - headSize; const eyeSize = headSize * 0.18;
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xFFCC99 }); const torsoMaterial = new THREE.MeshLambertMaterial({ color: 0x0088FF }); const limbMaterial = new THREE.MeshLambertMaterial({ color: 0x333399 }); const eyeMaterial = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const headGeo = new THREE.BoxGeometry(headSize, headSize, headSize); const torsoGeo = new THREE.BoxGeometry(torsoWidth, torsoHeight, torsoDepth); const armGeo = new THREE.BoxGeometry(limbWidth, armHeight, limbWidth); const legGeo = new THREE.BoxGeometry(limbWidth, legHeight, limbWidth); const eyeGeo = new THREE.BoxGeometry(eyeSize, eyeSize, eyeSize);
            const head = new THREE.Mesh(headGeo, headMaterial); const torso = new THREE.Mesh(torsoGeo, torsoMaterial); const leftArm = new THREE.Mesh(armGeo, limbMaterial); const rightArm = new THREE.Mesh(armGeo, limbMaterial); const leftLeg = new THREE.Mesh(legGeo, limbMaterial); const rightLeg = new THREE.Mesh(legGeo, limbMaterial); const leftEye = new THREE.Mesh(eyeGeo, eyeMaterial); const rightEye = new THREE.Mesh(eyeGeo, eyeMaterial);
            leftLeg.position.set(-torsoWidth / 2 + limbWidth / 2, legHeight / 2, 0); rightLeg.position.set(torsoWidth / 2 - limbWidth / 2, legHeight / 2, 0); torso.position.set(0, legHeight + torsoHeight / 2, 0); head.position.set(0, legHeight + torsoHeight + headSize / 2, 0); leftArm.position.set(-torsoWidth / 2 - limbWidth / 2, legHeight + torsoHeight - armHeight / 2, 0); rightArm.position.set(torsoWidth / 2 + limbWidth / 2, legHeight + torsoHeight - armHeight / 2, 0);
            const eyeOffsetZ = -headSize / 2 + eyeSize / 3; const eyeOffsetX = headSize * 0.25; const eyeOffsetY = headSize * 0.1;
            leftEye.position.set(-eyeOffsetX, eyeOffsetY, eyeOffsetZ); rightEye.position.set(eyeOffsetX, eyeOffsetY, eyeOffsetZ);
            head.add(leftEye); head.add(rightEye); head.name = 'playerHead';
            playerGroup.add(head); playerGroup.add(torso); playerGroup.add(leftArm); playerGroup.add(rightArm); playerGroup.add(leftLeg); playerGroup.add(rightLeg);
            playerGroup.traverse((child) => { if (child instanceof THREE.Mesh) { child.castShadow = true; child.receiveShadow = true; } });
            playerGroup.rotation.order = 'YXZ'; return playerGroup;
        }

        function addPeerRepresentation(id, position, rotation) { if (peers[id]) return; console.log(`Adding representation for peer: ${id}`); const playerModel = createPlayerModel(); playerModel.position.set(position.x, position.y - PLAYER_HEIGHT, position.z); playerModel.rotation.y = rotation._y; const head = playerModel.getObjectByName('playerHead'); if (head) { head.rotation.x = rotation._x; } peers[id] = { object: playerModel, lastUpdate: Date.now(), sentInit: false }; scene.add(playerModel); updatePlayerCount(); }
        function handleData(message) { const senderId = message.id; if (!senderId || senderId === peerId) return; switch (message.type) { case 'init': console.log("Init received from:", senderId); if (!peers[senderId]) { addPeerRepresentation(senderId, message.position, message.rotation); if (!peers[senderId]?.sentInit) { sendData({ type: 'init', id: peerId, position: camera.position, rotation: camera.rotation }); sendWorldState(); if(peers[senderId]) peers[senderId].sentInit = true; } } else { updatePeerRepresentation(senderId, message.position, message.rotation); } break; case 'worldStateChunk': message.blocks.forEach(blockData => { addBlock(blockData.p.x, blockData.p.y, blockData.p.z, blockData.t, false); }); break; case 'worldStateEnd': console.log(`Finished receiving world state from ${senderId}`); break; case 'update': updatePeerRepresentation(senderId, message.position, message.rotation); break; case 'addBlock': addBlock(message.position.x, message.position.y, message.position.z, message.blockType, false); break; case 'removeBlock': removeBlock(message.position.x, message.position.y, message.position.z, false); break; case 'requestInit': console.log("Received requestInit from", senderId); sendData({ type: 'init', id: peerId, position: camera.position, rotation: camera.rotation }); sendWorldState(); break; } }
        function updatePeerRepresentation(id, position, rotation) { if (!peers[id]) { console.log("Received update for unknown peer, adding representation:", id); addPeerRepresentation(id, position, rotation); } else if (peers[id].object) { const playerModel = peers[id].object; const targetPos = new THREE.Vector3( position.x, position.y - PLAYER_HEIGHT, position.z ); playerModel.position.lerp(targetPos, 0.3); playerModel.rotation.y = rotation._y; const head = playerModel.getObjectByName('playerHead'); if (head) { head.rotation.x = rotation._x; } peers[id].lastUpdate = Date.now(); } }
        function removePeerRepresentation(id) { if (peers[id] && peers[id].object) { scene.remove(peers[id].object); } delete peers[id]; updatePlayerCount(); console.log(`Removed representation for peer: ${id}`); }
        function updatePlayerCount() { const count = 1 + Object.keys(peers).length; playersEl.textContent = `Players: ${count}`; }

        function animate() { requestAnimationFrame(animate); const delta = Math.min(clock.getDelta(), 0.1); if (pointerLocked) { updatePlayerMovement(delta); updateBlockHighlight(); } updatePeers(delta); try { if (renderer && scene && camera) renderer.render(scene, camera); } catch (e) { console.error("Render error:", e); } }
        function updatePlayerMovement(delta) { const moveSpeed = PLAYER_SPEED; playerVelocity.y -= GRAVITY_ACCELERATION * delta; if (isJumpHeld && isOnGround) { playerVelocity.y = JUMP_VELOCITY; isOnGround = false; } const forward = new THREE.Vector3(); camera.getWorldDirection(forward); forward.y = 0; forward.normalize(); const right = new THREE.Vector3(); right.crossVectors(forward, camera.up).normalize(); let intendedVelocityX = 0; let intendedVelocityZ = 0; if (moveForward) { intendedVelocityX += forward.x; intendedVelocityZ += forward.z; } if (moveBackward) { intendedVelocityX -= forward.x; intendedVelocityZ -= forward.z; } if (moveLeft) { intendedVelocityX -= right.x; intendedVelocityZ -= right.z; } if (moveRight) { intendedVelocityX += right.x; intendedVelocityZ += right.z; } const horizontalMagnitude = Math.sqrt(intendedVelocityX * intendedVelocityX + intendedVelocityZ * intendedVelocityZ); if (horizontalMagnitude > 0) { playerVelocity.x = (intendedVelocityX / horizontalMagnitude) * moveSpeed; playerVelocity.z = (intendedVelocityZ / horizontalMagnitude) * moveSpeed; } else { playerVelocity.x = 0; playerVelocity.z = 0; } const playerHalfWidth = PLAYER_WIDTH / 2; const playerHalfDepth = PLAYER_WIDTH / 2; const feetLevelOffset = -PLAYER_HEIGHT; const eyeLevelOffset = 0.01; const deltaMovement = playerVelocity.clone().multiplyScalar(delta); isOnGround = false; const currentYPos = camera.position.y; const nextYPos = currentYPos + deltaMovement.y; const playerBoxY = new THREE.Box3(); playerBoxY.min.set(camera.position.x - playerHalfWidth, nextYPos + feetLevelOffset, camera.position.z - playerHalfDepth); playerBoxY.max.set(camera.position.x + playerHalfWidth, nextYPos + eyeLevelOffset, camera.position.z + playerHalfDepth); if (checkCollision(playerBoxY)) { if (playerVelocity.y <= 0) { let highestGroundY = -Infinity; for (let y = Math.floor(playerBoxY.min.y); y <= Math.floor(playerBoxY.max.y); y++) { for (let x = Math.floor(playerBoxY.min.x); x <= Math.floor(playerBoxY.max.x); x++) { for (let z = Math.floor(playerBoxY.min.z); z <= Math.floor(playerBoxY.max.z); z++) { if (getBlockAt(x, y, z)) { highestGroundY = Math.max(highestGroundY, y + 1); } } } } if (highestGroundY > -Infinity) { camera.position.y = highestGroundY + PLAYER_HEIGHT; playerVelocity.y = 0; isOnGround = true; } else { camera.position.y = currentYPos; playerVelocity.y = 0; } } else if (playerVelocity.y > 0) { let lowestCeilingY = Infinity; for (let y = Math.floor(playerBoxY.min.y); y <= Math.floor(playerBoxY.max.y); y++) { for (let x = Math.floor(playerBoxY.min.x); x <= Math.floor(playerBoxY.max.x); x++) { for (let z = Math.floor(playerBoxY.min.z); z <= Math.floor(playerBoxY.max.z); z++) { if (getBlockAt(x, y, z)) { lowestCeilingY = Math.min(lowestCeilingY, y); } } } } if (lowestCeilingY < Infinity) { camera.position.y = lowestCeilingY - eyeLevelOffset; playerVelocity.y = 0; } else { camera.position.y = currentYPos; playerVelocity.y = 0; } } } else { camera.position.y = nextYPos; } const currentXPos = camera.position.x; const nextXPos = currentXPos + deltaMovement.x; const playerBoxX = new THREE.Box3(); playerBoxX.min.set(nextXPos - playerHalfWidth, camera.position.y + feetLevelOffset, camera.position.z - playerHalfDepth); playerBoxX.max.set(nextXPos + playerHalfWidth, camera.position.y + eyeLevelOffset, camera.position.z + playerHalfDepth); if (checkCollision(playerBoxX)) { playerVelocity.x = 0; if (deltaMovement.x > 0) camera.position.x = Math.floor(nextXPos + playerHalfWidth) - playerHalfWidth - 0.01; else if (deltaMovement.x < 0) camera.position.x = Math.floor(nextXPos - playerHalfWidth) + 1 + playerHalfWidth + 0.01; } else { camera.position.x = nextXPos; } const currentZPos = camera.position.z; const nextZPos = currentZPos + deltaMovement.z; const playerBoxZ = new THREE.Box3(); playerBoxZ.min.set(camera.position.x - playerHalfWidth, camera.position.y + feetLevelOffset, nextZPos - playerHalfDepth); playerBoxZ.max.set(camera.position.x + playerHalfWidth, camera.position.y + eyeLevelOffset, nextZPos + playerHalfDepth); if (checkCollision(playerBoxZ)) { playerVelocity.z = 0; if (deltaMovement.z > 0) camera.position.z = Math.floor(nextZPos + playerHalfDepth) - playerHalfDepth - 0.01; else if (deltaMovement.z < 0) camera.position.z = Math.floor(nextZPos - playerHalfDepth) + 1 + playerHalfDepth + 0.01; } else { camera.position.z = nextZPos; } if (camera.position.y < -10) { camera.position.set(0, WORLD_HEIGHT + PLAYER_HEIGHT + 2, 0); playerVelocity.set(0,0,0); isOnGround = false; } }
        function updateBlockHighlight() {  const intersect = getIntersectingBlock(); if (intersect) { const highlightPos = intersect.object.position.clone(); highlightMesh.position.copy(highlightPos); highlightMesh.visible = true; } else { highlightMesh.visible = false; } }
        const updateInterval = 100; const peerTimeout = 10000;
        function updatePeers(delta) { const now = Date.now(); if (peer && peer.connected && (now - lastUpdateTime > updateInterval)) { sendData({ type: 'update', id: peerId, position: camera.position, rotation: { _x: camera.rotation.x, _y: camera.rotation.y, _z: camera.rotation.z } }); lastUpdateTime = now; } for (const pId in peers) { if (now - peers[pId].lastUpdate > peerTimeout) { console.log(`Peer ${pId} timed out.`); removePeerRepresentation(pId); } } }

        document.addEventListener('DOMContentLoaded', (event) => { console.log('DOM fully loaded and parsed'); try { init(); } catch (error) { console.error("Error during initialization:", error); document.getElementById('status').textContent = "Initialization Error! Check Console."; if (blocker) blocker.style.display = 'flex'; if (blockerInstructions) blockerInstructions.innerHTML = `<h2>Error!</h2><p>Game failed to initialize...</p><p>${error.message}</p>`; } });

    </script>
</body>

</html>
