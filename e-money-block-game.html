<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>E-Money Block Game Alpha v2.0</title>
    <style>
        /* CSS remains the same */
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: Arial, sans-serif; color: #333; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; max-width: 380px; border: 1px solid #bbb; box-shadow: 0 4px 8px rgba(0,0,0,0.2); z-index: 20; }
        #blocker { position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.75); display: flex; justify-content: center; align-items: center; color: white; z-index: 10; }
        #instructions { position: absolute; bottom: 10px; left: 10px; background: rgba(0,0,0,0.6); padding: 8px; border-radius: 4px; font-size: 0.9em; color: white; z-index: 5; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background-color: white; transform: translate(-50%, -50%); border-radius: 0px; mix-blend-mode: difference; border: 1px solid black; z-index: 5;}
        #connectionInfo { margin-top: 10px; }
        textarea { width: 100%; min-height: 60px; margin-top: 5px; box-sizing: border-box; background: #f8f8f8; color: #333; border: 1px solid #ccc; font-size: 0.85em; padding: 5px; }
        button { margin-top: 8px; padding: 10px 15px; cursor: pointer; background: #5cb85c; color: white; border: none; border-radius: 5px; font-size: 0.95em; transition: background-color 0.2s ease; }
        button:hover { background: #4cae4c; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #inviteLink { margin-top: 5px; background: #e9e9e9; padding: 8px; border: 1px dashed #ccc; word-wrap: break-word; font-size: 0.8em; max-height: 60px; overflow-y: auto; }
        label { display: block; margin-top: 10px; font-weight: bold; font-size: 0.9em; }
        #blockerInstructions { width: 80%; max-width: 450px; background: #333; padding: 25px; border-radius: 10px; text-align: center; border: 1px solid #555; }
        h2, h3 { margin-top: 0; color: #eee; }
        hr { border: 0; height: 1px; background: #555; margin: 15px 0; }
        strong { color: #444; }
    </style>
</head>
<body>
    <!-- HTML structure remains the same -->
     <div id="blocker"> <div id="blockerInstructions"> <h2>E-Money Block Game Alpha v2.0</h2> <p>Click anywhere to start playing!</p> <p>(Requires Pointer Lock)</p> <hr> <h3>Controls:</h3> <p>W/A/S/D: Move | Space: Fly Up | Shift: Fly Down</p> <p>Mouse: Look | Left Click: Destroy Block | Right Click: Place Block</p> <p>ESC: Release Mouse</p> <hr> <p>Use the UI (Top Left) to connect...</p> </div> </div>
     <div id="ui"> <div><strong>Status:</strong> <span id="status">Initializing...</span></div> <div id="players">Players: 1</div> <div id="connectionInfo"> <hr> <button id="createInviteBtn">1. Create Invite Link</button> <div id="inviteLinkContainer" style="display:none;"> <label>Send this link to friend:</label> <div id="inviteLink"></div> <label for="answerInputArea">2. Paste their Answer here:</label> <textarea id="answerInputArea" placeholder="Paste Answer data from friend here"></textarea> <button id="submitAnswerBtn">3. Submit Answer</button> </div> <div id="joinGameContainer" style="display:none;"> <label for="offerDisplayArea">Offer Received (from link):</label> <textarea id="offerDisplayArea" readonly></textarea> <button id="createAnswerBtn">1. Create Answer</button> <label for="answerOutputArea" style="display:none;">2. Copy this Answer...</label> <textarea id="answerOutputArea" style="display:none;" readonly></textarea> </div> </div> </div>
     <div id="instructions"> W/A/S/D: Move | Space: Up | Shift: Down | Mouse: Look | LClick: Destroy | RClick: Place | ESC: Unlock Mouse </div>
     <div id="crosshair"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>

    <script>
        // --- Configuration (Unchanged) ---
        const PLAYER_HEIGHT = 1.8; const PLAYER_SPEED = 5.0; const MOUSE_SENSITIVITY = 0.002; const BLOCK_SIZE = 1;
        const WORLD_SIZE_X = 20; const WORLD_SIZE_Z = 20; const WORLD_HEIGHT = 8; const REACH_DISTANCE = 6;

        // --- Asset Data URLs (REMOVED - Using Canvas now) ---

        // --- Global Variables ---
        let scene, camera, renderer; let world = {}; let playerVelocity = new THREE.Vector3(); let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, moveUp = false, moveDown = false;
        let peer; let peers = {}; let peerId; let clock = new THREE.Clock(); let raycaster = new THREE.Raycaster();
        let blockGeometry;
        let blockMaterials = {}; // Populated synchronously now
        let textures = {};       // Store canvas textures
        let highlightMaterial, highlightMesh;
        // const textureLoader = new THREE.TextureLoader(); // REMOVED - Not needed for CanvasTexture
        let pointerLocked = false;
        // let texturesLoaded = false; // REMOVED - Canvas textures are available immediately

        // --- UI Elements (Unchanged) ---
        const blocker = document.getElementById('blocker'); const statusEl = document.getElementById('status'); const createInviteBtn = document.getElementById('createInviteBtn'); const inviteLinkContainer = document.getElementById('inviteLinkContainer'); const inviteLinkEl = document.getElementById('inviteLink'); const answerInputArea = document.getElementById('answerInputArea'); const submitAnswerBtn = document.getElementById('submitAnswerBtn'); const joinGameContainer = document.getElementById('joinGameContainer'); const offerDisplayArea = document.getElementById('offerDisplayArea'); const createAnswerBtn = document.getElementById('createAnswerBtn'); const answerOutputArea = document.getElementById('answerOutputArea'); const answerOutputLabel = document.querySelector('label[for="answerOutputArea"]'); const playersEl = document.getElementById('players');

        // --- Initialization ---
        function init() {
             console.log("init() started..."); peerId = 'user_' + Math.random().toString(36).substring(2, 9); console.log("My Peer ID:", peerId);
             setupScene(); setupPlayer(); setupLighting();
             setupBlockGeometry();
             setupTexturesAndMaterials(); // <<< CHANGED: Uses Canvas now, synchronous
             setupWorld(); // World uses final materials immediately
             setupBlockHighlight(); setupControls(); setupEventListeners(); setupWebRTCUI(); checkUrlForOffer();
             console.log("init() finished."); animate();
        }

        function setupScene() { /* Unchanged */
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0x87CEEB, 10, 150);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement); console.log("setupScene() complete.");
        }

        function setupPlayer() { /* Unchanged */
             camera.position.set(0, WORLD_HEIGHT + PLAYER_HEIGHT + 2, 5); camera.rotation.order = 'YXZ'; console.log("setupPlayer() complete.");
        }

        function setupBlockGeometry() {
             blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
             console.log("Block geometry created.");
         }

        // <<< REPLACED: Setup Textures and Materials using Canvas >>>
        function setupTexturesAndMaterials() {
             blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
             console.log("Creating textures programmatically via Canvas...");

             const textureSize = 16; // Texture dimension

             // Helper to create a CanvasTexture and apply common settings
             function createCanvasTexture(drawFunction) {
                 const canvas = document.createElement('canvas');
                 canvas.width = textureSize;
                 canvas.height = textureSize;
                 const context = canvas.getContext('2d');
                 drawFunction(context, textureSize); // Call the drawing function
                 const texture = new THREE.CanvasTexture(canvas);
                 texture.magFilter = THREE.NearestFilter;
                 texture.minFilter = THREE.NearestFilter;
                 texture.needsUpdate = true; // Required for CanvasTexture initially
                 return texture;
             }

             // --- Drawing Functions ---
             function drawDirt(ctx, size) {
                 ctx.fillStyle = '#8B4513'; // SaddleBrown
                 ctx.fillRect(0, 0, size, size);
                 // Add some noise
                 ctx.fillStyle = 'rgba(0,0,0,0.1)';
                 for (let i=0; i < size*size*0.3; ++i) {
                     ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1);
                 }
             }

             function drawStone(ctx, size) {
                 ctx.fillStyle = '#808080'; // Gray
                 ctx.fillRect(0, 0, size, size);
                 // Add some noise
                 ctx.fillStyle = 'rgba(0,0,0,0.15)';
                 for (let i=0; i < size*size*0.4; ++i) {
                     ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1);
                 }
                 ctx.fillStyle = 'rgba(255,255,255,0.1)';
                 for (let i=0; i < size*size*0.2; ++i) {
                     ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1);
                 }
             }

             function drawGrassTop(ctx, size) {
                 ctx.fillStyle = '#5a9a5a'; // Greener grass
                 ctx.fillRect(0, 0, size, size);
                 // Add noise
                 ctx.fillStyle = 'rgba(0,0,0,0.1)';
                 for (let i=0; i < size*size*0.3; ++i) {
                     ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1);
                 }
                  ctx.fillStyle = 'rgba(255,255,255,0.05)';
                 for (let i=0; i < size*size*0.2; ++i) {
                     ctx.fillRect(Math.random()*size, Math.random()*size, 1, 1);
                 }
             }

             function drawGrassSide(ctx, size) {
                 // Top grass part
                 ctx.fillStyle = '#5a9a5a'; // Greener grass
                 ctx.fillRect(0, 0, size, size * 0.25); // Top 25% green
                  // Dirt part
                 ctx.fillStyle = '#8B4513'; // Dirt brown
                 ctx.fillRect(0, size * 0.25, size, size * 0.75); // Bottom 75% dirt
                 // Add noise to dirt
                  ctx.fillStyle = 'rgba(0,0,0,0.1)';
                 for (let i=0; i < size*size*0.75*0.3; ++i) { // Noise only in dirt area
                     ctx.fillRect(Math.random()*size, size*0.25 + Math.random()*size*0.75, 1, 1);
                 }
             }

             // Create the textures using canvas helpers
             textures = {
                 grassTop: createCanvasTexture(drawGrassTop),
                 grassSide: createCanvasTexture(drawGrassSide),
                 dirt: createCanvasTexture(drawDirt),
                 stone: createCanvasTexture(drawStone)
             };
             console.log("Canvas textures created.");

             // Create materials using the canvas textures
             console.log("Creating final block materials from canvas textures...");
              blockMaterials = {
                  grass: [
                      new THREE.MeshLambertMaterial({ map: textures.grassSide }), // r
                      new THREE.MeshLambertMaterial({ map: textures.grassSide }), // l
                      new THREE.MeshLambertMaterial({ map: textures.grassTop }),  // t
                      new THREE.MeshLambertMaterial({ map: textures.dirt }),      // b
                      new THREE.MeshLambertMaterial({ map: textures.grassSide }), // f
                      new THREE.MeshLambertMaterial({ map: textures.grassSide })  // bk
                  ],
                  dirt: new THREE.MeshLambertMaterial({ map: textures.dirt }),
                  stone: new THREE.MeshLambertMaterial({ map: textures.stone }),
              };
             blockMaterials.fallback = new THREE.MeshLambertMaterial({ color: 0xff00ff }); // Magenta fallback if type is wrong

             console.log("Canvas-based materials created and assigned.");
         }


        function setupWorld() {
             console.log("Generating world terrain (using final canvas materials)..."); // Uses final materials directly
             for (let x = -WORLD_SIZE_X / 2; x < WORLD_SIZE_X / 2; x++) {
                 for (let z = -WORLD_SIZE_Z / 2; z < WORLD_SIZE_Z / 2; z++) {
                     for (let y = 0; y < WORLD_HEIGHT; y++) {
                         let blockType;
                         if (y === WORLD_HEIGHT - 1) blockType = 'grass';
                         else if (y >= WORLD_HEIGHT - 4 && y < WORLD_HEIGHT -1) blockType = 'dirt';
                         else blockType = 'stone';
                         addBlock(x, y, z, blockType, false);
                     }
                 }
             }
             console.log("World terrain generation complete.");
             console.log("setupWorld() complete.");
        }

        // <<< Simplified addBlock - uses materials directly >>>
        function addBlock(x, y, z, type, broadcast = true) {
            const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
            if (world[key]) return;

            // Get the material - should always be available now
            let material = blockMaterials[type] || blockMaterials.fallback;

            if (!material) { // Should ideally not happen with fallback
                console.error(`FATAL: No material found for type "${type}" or fallback!`);
                material = blockMaterials.fallback || new THREE.MeshLambertMaterial({color: 0xff00ff});
            }

            const block = new THREE.Mesh(blockGeometry, material);
            block.position.set(x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2, z + BLOCK_SIZE / 2);
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = { type: type };
            scene.add(block);
            world[key] = { mesh: block, type: type };

            // No need to check texturesLoaded anymore

            if (broadcast && peer && peer.connected) {
                sendData({ type: 'addBlock', id: peerId, position: { x, y, z }, blockType: type });
            }
        }


        function removeBlock(x, y, z, broadcast = true) { /* Unchanged */
            const key = `${Math.round(x)},${Math.round(y)},${Math.round(z)}`;
            if (world[key]) {
                scene.remove(world[key].mesh);
                delete world[key];
                if (broadcast && peer && peer.connected) {
                    sendData({ type: 'removeBlock', id: peerId, position: { x, y, z } });
                }
                return true;
            }
            return false;
        }

        function setupLighting() { /* Unchanged */
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.8); scene.add(ambientLight);
            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444, 0.7 ); hemiLight.position.set( 0, 20, 0 ); scene.add( hemiLight );
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7); directionalLight.position.set(50, 80, 30);
            directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 10; directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -60; directionalLight.shadow.camera.right = 60;
            directionalLight.shadow.camera.top = 60; directionalLight.shadow.camera.bottom = -60;
            scene.add(directionalLight); console.log("Lighting Setup Complete."); console.log("setupLighting() complete.");
        }

        function setupBlockHighlight() { /* Unchanged */
             const highlightGeometry = new THREE.BoxGeometry(BLOCK_SIZE * 1.01, BLOCK_SIZE * 1.01, BLOCK_SIZE * 1.01);
             highlightMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.7 });
             highlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
             highlightMesh.visible = false; scene.add(highlightMesh); console.log("setupBlockHighlight() complete.");
        }

        // --- Controls and Event Listeners (Unchanged) ---
        function setupControls() { blocker.addEventListener('click', () => { if (document.body.requestPointerLock) document.body.requestPointerLock(); else console.error("Pointer Lock API not supported/enabled."); }); document.addEventListener('pointerlockchange', lockChangeAlert, false); document.addEventListener('mozpointerlockchange', lockChangeAlert, false); document.addEventListener('webkitpointerlockchange', lockChangeAlert, false); function lockChangeAlert() { pointerLocked = (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body || document.webkitPointerLockElement === document.body); if (pointerLocked) { console.log('Pointer Lock engaged'); blocker.style.display = 'none'; document.addEventListener("mousemove", onMouseMove, false); } else { console.log('Pointer Lock released'); blocker.style.display = 'flex'; document.removeEventListener("mousemove", onMouseMove, false); moveForward = moveBackward = moveLeft = moveRight = moveUp = moveDown = false; } } const onMouseMove = (event) => { if (!pointerLocked) return; const movementX = event.movementX || 0; const movementY = event.movementY || 0; camera.rotation.y -= movementX * MOUSE_SENSITIVITY; camera.rotation.x -= movementY * MOUSE_SENSITIVITY; camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x)); }; console.log("setupControls() complete."); }
        function setupEventListeners() { window.addEventListener('resize', onWindowResize, false); document.addEventListener('keydown', onKeyDown, false); document.addEventListener('keyup', onKeyUp, false); document.addEventListener('mousedown', onMouseDown, false); document.addEventListener('contextmenu', (e) => { if(pointerLocked) e.preventDefault(); }, false); console.log("setupEventListeners() complete."); }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onKeyDown(event) { if (!pointerLocked) return; switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = true; break; case 'KeyS': case 'ArrowDown': moveBackward = true; break; case 'KeyA': case 'ArrowLeft': moveLeft = true; break; case 'KeyD': case 'ArrowRight': moveRight = true; break; case 'Space': moveUp = true; break; case 'ShiftLeft': case 'ShiftRight': moveDown = true; break; case 'Escape': if(document.pointerLockElement) document.exitPointerLock(); break; } }
        function onKeyUp(event) { switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = false; break; case 'KeyS': case 'ArrowDown': moveBackward = false; break; case 'KeyA': case 'ArrowLeft': moveLeft = false; break; case 'KeyD': case 'ArrowRight': moveRight = false; break; case 'Space': moveUp = false; break; case 'ShiftLeft': case 'ShiftRight': moveDown = false; break; } }
        function onMouseDown(event) { if (!pointerLocked) return; const intersect = getIntersectingBlock(); if (!intersect) return; const blockMesh = intersect.object; const blockCenter = blockMesh.position; const normal = intersect.face.normal; if (event.button === 0) { const coords = { x: Math.round(blockCenter.x - BLOCK_SIZE/2), y: Math.round(blockCenter.y - BLOCK_SIZE/2), z: Math.round(blockCenter.z - BLOCK_SIZE/2) }; removeBlock(coords.x, coords.y, coords.z, true); } else if (event.button === 2) { const placePos = new THREE.Vector3(); intersect.point.addScaledVector(normal, 0.1); placePos.copy(intersect.point).add(normal.clone().multiplyScalar(BLOCK_SIZE * 0.5)); const coords = { x: Math.floor(placePos.x), y: Math.floor(placePos.y), z: Math.floor(placePos.z) }; const playerBB = new THREE.Box3().setFromCenterAndSize(camera.position, new THREE.Vector3(0.8, PLAYER_HEIGHT, 0.8)); const blockBB = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(coords.x + 0.5, coords.y + 0.5, coords.z + 0.5), new THREE.Vector3(1,1,1)); if (!playerBB.intersectsBox(blockBB)) { addBlock(coords.x, coords.y, coords.z, 'stone', true); } else { console.log("Cannot place block inside player"); } } }
         function getIntersectingBlock() { raycaster.setFromCamera({ x: 0, y: 0 }, camera); const worldMeshes = Object.values(world).map(b => b.mesh).filter(mesh => mesh); if (worldMeshes.length === 0) return null; const intersects = raycaster.intersectObjects(worldMeshes); for(let i = 0; i < intersects.length; i++) { if (intersects[i].distance <= REACH_DISTANCE) return intersects[i]; } return null; }

        // --- WebRTC Setup (Unchanged) ---
        function checkUrlForOffer() { const hash = window.location.hash.substring(1); if (hash.startsWith('offer=')) { const encodedOffer = hash.substring(6); try { const offerJson = atob(encodedOffer); const offer = JSON.parse(offerJson); console.log("Received offer from URL:", offer); offerDisplayArea.value = offerJson; joinGameContainer.style.display = 'block'; createInviteBtn.style.display = 'none'; statusEl.textContent = "Offer Received. Create Answer."; startPeer(false); if (peer) { peer.signal(offer); } else { console.error("Peer object not created before signaling in checkUrlForOffer"); statusEl.textContent = "Error: Peer setup failed."; } } catch (err) { console.error("Error decoding/parsing offer from URL:", err); statusEl.textContent = "Error: Invalid invite link."; resetConnectionUI(true); } } else { console.log("No offer found in URL hash."); resetConnectionUI(true); } console.log("checkUrlForOffer() complete."); }
        function setupWebRTCUI() { createInviteBtn.onclick = () => { console.log("Create Invite Link button clicked."); startPeer(true); createInviteBtn.disabled = true; statusEl.textContent = "Creating offer..."; }; createAnswerBtn.onclick = () => { console.log("Create Answer button clicked."); createAnswerBtn.disabled = true; statusEl.textContent = "Generating Answer..."; }; submitAnswerBtn.onclick = () => { console.log("Submit Answer button clicked."); const answerJson = answerInputArea.value.trim(); if (answerJson && peer) { try { peer.signal(JSON.parse(answerJson)); submitAnswerBtn.disabled = true; answerInputArea.disabled = true; statusEl.textContent = "Answer submitted, connecting..."; } catch (err) { console.error("Error parsing answer:", err); alert("Invalid answer JSON."); statusEl.textContent = "Error: Invalid Answer format."; submitAnswerBtn.disabled = false; answerInputArea.disabled = false; } } else { alert("Paste the Answer signal data first."); } }; console.log("setupWebRTCUI() complete."); }
        function startPeer(initiator = false) { console.log(`startPeer() called. Initiator: ${initiator}`); if (peer) { console.log("Destroying existing peer connection before creating new one."); peer.destroy(); peer = null; } statusEl.textContent = 'Initializing Peer...'; try { peer = new SimplePeer({ initiator: initiator, trickle: false, }); console.log("SimplePeer object created."); peer.on('error', err => { console.error('Peer Error:', err); statusEl.textContent = `Error: ${err.message}`; resetConnectionUI(); }); peer.on('signal', data => { console.log(`peer.on('signal') fired. Signal type: ${data.type}`); const signalDataJson = JSON.stringify(data); console.log('SIGNAL data:', signalDataJson); if (data.type === 'offer') { const encodedOffer = btoa(signalDataJson); const inviteUrl = window.location.origin + window.location.pathname + '#offer=' + encodedOffer; inviteLinkEl.textContent = inviteUrl; inviteLinkContainer.style.display = 'block'; statusEl.textContent = 'Invite link created. Send it and wait for answer.'; console.log("Offer generated and UI updated."); } else if (data.type === 'answer') { answerOutputArea.value = signalDataJson; answerOutputArea.style.display = 'block'; answerOutputLabel.style.display = 'block'; statusEl.textContent = 'Answer created. Copy it and send back.'; console.log("Answer generated and UI updated."); } }); peer.on('connect', () => { console.log('CONNECT event fired.'); statusEl.textContent = 'Connected!'; document.getElementById('connectionInfo').style.display = 'none'; sendData({ type: 'init', id: peerId, position: camera.position, rotation: camera.rotation }); sendWorldState(); }); peer.on('data', data => { try { const message = JSON.parse(data.toString()); handleData(message); } catch (err) { console.error("Failed to parse received data:", data.toString(), err); } }); peer.on('close', () => { console.log('CLOSE event fired.'); statusEl.textContent = 'Disconnected'; resetConnectionUI(); for (const pId in peers) removePeerRepresentation(pId); }); } catch (error) { console.error("Error creating SimplePeer object:", error); statusEl.textContent = "Error: Failed to initialize WebRTC."; resetConnectionUI(); } }
        function resetConnectionUI(isInitial = false) { statusEl.textContent = isInitial ? 'Ready' : 'Disconnected'; console.log(`resetConnectionUI called. isInitial: ${isInitial}, Status set to: ${statusEl.textContent}`); inviteLinkContainer.style.display = 'none'; joinGameContainer.style.display = 'none'; createInviteBtn.style.display = 'block'; createInviteBtn.disabled = false; answerInputArea.value = ''; answerInputArea.disabled = false; submitAnswerBtn.disabled = false; offerDisplayArea.value = ''; createAnswerBtn.disabled = false; answerOutputArea.value = ''; answerOutputArea.style.display = 'none'; answerOutputLabel.style.display = 'none'; if (!isInitial && window.location.hash) { console.log("Clearing URL hash."); history.pushState("", document.title, window.location.pathname + window.location.search); } if (peer) { console.log("Destroying peer object in resetConnectionUI."); peer.destroy(); peer = null; } const currentPeers = Object.keys(peers); if(currentPeers.length > 0) { console.log("Removing peer representations in resetConnectionUI."); for (const pId in peers) removePeerRepresentation(pId); } updatePlayerCount(); }
        function sendData(data) { if (peer && peer.connected) { try { peer.send(JSON.stringify(data)); } catch (err) { console.error("Error sending data:", err, data); } } }
        function sendWorldState() { if (!peer || !peer.connected) return; console.log("Sending initial world state..."); const worldData = []; for (const key in world) { if (world[key]) { const [x, y, z] = key.split(',').map(Number); worldData.push({ p: { x, y, z }, t: world[key].type }); } } const chunkSize = 50; for (let i = 0; i < worldData.length; i += chunkSize) { const chunk = worldData.slice(i, i + chunkSize); sendData({ type: 'worldStateChunk', id: peerId, blocks: chunk }); } sendData({ type: 'worldStateEnd', id: peerId }); console.log(`Sent world state in ${Math.ceil(worldData.length/chunkSize)} chunks.`); }

        // --- Data Handling (Unchanged) ---
        function addPeerRepresentation(id, position, rotation) { if (peers[id]) return; console.log(`Adding representation for peer: ${id}`); const geometry = new THREE.CapsuleGeometry(0.4, PLAYER_HEIGHT - 0.8, 4, 8); let hash = 0; for (let i = 0; i < id.length; i++) { hash = id.charCodeAt(i) + ((hash << 5) - hash); } const color = (hash & 0x00FFFFFF) | 0x909090; const material = new THREE.MeshLambertMaterial({ color: new THREE.Color(color) }); const peerObject = new THREE.Mesh(geometry, material); peerObject.castShadow = true; peerObject.rotation.order = 'YXZ'; peers[id] = { object: peerObject, lastUpdate: Date.now(), sentInit: false }; updatePeerRepresentation(id, position, rotation); scene.add(peerObject); updatePlayerCount(); }
        function handleData(message) { const senderId = message.id; if (!senderId || senderId === peerId) return; switch (message.type) { case 'init': console.log("Init received from:", senderId); if (!peers[senderId]) { addPeerRepresentation(senderId, message.position, message.rotation); if (!peers[senderId]?.sentInit) { sendData({ type: 'init', id: peerId, position: camera.position, rotation: camera.rotation }); sendWorldState(); if(peers[senderId]) peers[senderId].sentInit = true; } } else { updatePeerRepresentation(senderId, message.position, message.rotation); } break; case 'worldStateChunk': message.blocks.forEach(blockData => { addBlock(blockData.p.x, blockData.p.y, blockData.p.z, blockData.t, false); }); break; case 'worldStateEnd': console.log(`Finished receiving world state from ${senderId}`); break; case 'update': updatePeerRepresentation(senderId, message.position, message.rotation); break; case 'addBlock': addBlock(message.position.x, message.position.y, message.position.z, message.blockType, false); break; case 'removeBlock': removeBlock(message.position.x, message.position.y, message.position.z, false); break; case 'requestInit': console.log("Received requestInit from", senderId); sendData({ type: 'init', id: peerId, position: camera.position, rotation: camera.rotation }); sendWorldState(); break; } }
        function updatePeerRepresentation(id, position, rotation) { if (!peers[id]) { console.log("Received update for unknown peer, adding representation:", id); addPeerRepresentation(id, position, rotation); } else if (peers[id].object) { const targetPos = new THREE.Vector3(position.x, position.y, position.z); const targetRot = new THREE.Euler(rotation._x, rotation._y, rotation._z, 'YXZ'); peers[id].object.position.lerp(targetPos, 0.3); peers[id].object.rotation.copy(targetRot); peers[id].lastUpdate = Date.now(); } }
        function removePeerRepresentation(id) { if (peers[id] && peers[id].object) { scene.remove(peers[id].object); } delete peers[id]; updatePlayerCount(); console.log(`Removed representation for peer: ${id}`); }
        function updatePlayerCount() { const count = 1 + Object.keys(peers).length; playersEl.textContent = `Players: ${count}`; }

        // --- Game Loop (Unchanged) ---
        function animate() { requestAnimationFrame(animate); const delta = clock.getDelta(); if (pointerLocked) { updatePlayerMovement(delta); updateBlockHighlight(); } updatePeers(delta); try { if (renderer && scene && camera) { renderer.render(scene, camera); } } catch (e) { console.error("Render error:", e); } }
        function updatePlayerMovement(delta) { const moveSpeed = PLAYER_SPEED * delta; const direction = new THREE.Vector3(); camera.getWorldDirection(direction); const right = new THREE.Vector3(); right.crossVectors(direction, camera.up).normalize(); playerVelocity.set(0, 0, 0); const forward = new THREE.Vector3(direction.x, 0, direction.z).normalize(); if (moveForward) playerVelocity.add(forward); if (moveBackward) playerVelocity.sub(forward); if (moveLeft) playerVelocity.sub(right); if (moveRight) playerVelocity.add(right); if (moveUp) playerVelocity.y += 1; if (moveDown) playerVelocity.y -= 1; playerVelocity.multiplyScalar(moveSpeed); camera.position.add(playerVelocity); if (camera.position.y < -10) { camera.position.set(0, WORLD_HEIGHT + PLAYER_HEIGHT + 2, 0); } }
        function updateBlockHighlight() { const intersect = getIntersectingBlock(); if (intersect) { const highlightPos = intersect.object.position.clone(); highlightMesh.position.copy(highlightPos); highlightMesh.visible = true; } else { highlightMesh.visible = false; } }
        let lastUpdateTime = 0; const updateInterval = 100; const peerTimeout = 10000;
        function updatePeers(delta) { const now = Date.now(); if (peer && peer.connected && (now - lastUpdateTime > updateInterval)) { sendData({ type: 'update', id: peerId, position: camera.position, rotation: { _x: camera.rotation.x, _y: camera.rotation.y, _z: camera.rotation.z } }); lastUpdateTime = now; } for (const pId in peers) { if (now - peers[pId].lastUpdate > peerTimeout) { console.log(`Peer ${pId} timed out.`); removePeerRepresentation(pId); } } }


        // --- Start the game ---
        document.addEventListener('DOMContentLoaded', (event) => {
             console.log('DOM fully loaded and parsed'); try { init(); } catch (error) { console.error("Error during initialization:", error); document.getElementById('status').textContent = "Initialization Error! Check Console."; if (blocker) blocker.style.display = 'flex'; if (blockerInstructions) blockerInstructions.innerHTML = `<h2>Error!</h2><p>Game failed to initialize...</p><p>${error.message}</p>`; }
        });

    </script>
</body>
</html>